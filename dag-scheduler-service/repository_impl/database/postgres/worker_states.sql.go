// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: worker_states.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const getCurrentWorkerStateOfWorker = `-- name: GetCurrentWorkerStateOfWorker :one
SELECT id, dag_id, worker_id, worker_status, start_time, end_time, retry_count, failure_reason, created_at
FROM worker_states
WHERE worker_id=$1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetCurrentWorkerStateOfWorker(ctx context.Context, workerID uuid.UUID) (WorkerState, error) {
	row := q.db.QueryRow(ctx, getCurrentWorkerStateOfWorker, workerID)
	var i WorkerState
	err := row.Scan(
		&i.ID,
		&i.DagID,
		&i.WorkerID,
		&i.WorkerStatus,
		&i.StartTime,
		&i.EndTime,
		&i.RetryCount,
		&i.FailureReason,
		&i.CreatedAt,
	)
	return i, err
}

const incrementWorkerStateRetryCount = `-- name: IncrementWorkerStateRetryCount :exec
UPDATE worker_states
SET retry_count=retry_count+1
WHERE id=$1
`

func (q *Queries) IncrementWorkerStateRetryCount(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, incrementWorkerStateRetryCount, id)
	return err
}

const listWorkerStatesOfWorker = `-- name: ListWorkerStatesOfWorker :many
SELECT id, dag_id, worker_id, worker_status, start_time, end_time, retry_count, failure_reason, created_at
FROM worker_states
WHERE worker_id=$1
`

func (q *Queries) ListWorkerStatesOfWorker(ctx context.Context, workerID uuid.UUID) ([]WorkerState, error) {
	rows, err := q.db.Query(ctx, listWorkerStatesOfWorker, workerID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []WorkerState
	for rows.Next() {
		var i WorkerState
		if err := rows.Scan(
			&i.ID,
			&i.DagID,
			&i.WorkerID,
			&i.WorkerStatus,
			&i.StartTime,
			&i.EndTime,
			&i.RetryCount,
			&i.FailureReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateWorkerStateEndTime = `-- name: UpdateWorkerStateEndTime :exec
UPDATE worker_states
SET end_time=$2
WHERE id=$1
`

type UpdateWorkerStateEndTimeParams struct {
	ID      uuid.UUID        `json:"id"`
	EndTime pgtype.Timestamp `json:"end_time"`
}

func (q *Queries) UpdateWorkerStateEndTime(ctx context.Context, arg UpdateWorkerStateEndTimeParams) error {
	_, err := q.db.Exec(ctx, updateWorkerStateEndTime, arg.ID, arg.EndTime)
	return err
}

const updateWorkerStateFailureReason = `-- name: UpdateWorkerStateFailureReason :exec
UPDATE worker_states
SET failure_reason=$2
WHERE id=$1
`

type UpdateWorkerStateFailureReasonParams struct {
	ID            uuid.UUID   `json:"id"`
	FailureReason pgtype.Text `json:"failure_reason"`
}

func (q *Queries) UpdateWorkerStateFailureReason(ctx context.Context, arg UpdateWorkerStateFailureReasonParams) error {
	_, err := q.db.Exec(ctx, updateWorkerStateFailureReason, arg.ID, arg.FailureReason)
	return err
}

const updateWorkerStateStartTime = `-- name: UpdateWorkerStateStartTime :exec
UPDATE worker_states
SET start_time=$2
WHERE id=$1
`

type UpdateWorkerStateStartTimeParams struct {
	ID        uuid.UUID        `json:"id"`
	StartTime pgtype.Timestamp `json:"start_time"`
}

func (q *Queries) UpdateWorkerStateStartTime(ctx context.Context, arg UpdateWorkerStateStartTimeParams) error {
	_, err := q.db.Exec(ctx, updateWorkerStateStartTime, arg.ID, arg.StartTime)
	return err
}
