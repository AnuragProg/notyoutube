// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: dag_states.sql

package postgres

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const createDAGState = `-- name: CreateDAGState :one
INSERT INTO dag_states (
    id, dag_id, dag_status
)
VALUES ($1, $2, $3)
RETURNING id, dag_id, dag_status, start_time, end_time, failure_reason, created_at
`

type CreateDAGStateParams struct {
	ID        uuid.UUID `json:"id"`
	DagID     uuid.UUID `json:"dag_id"`
	DagStatus DagStatus `json:"dag_status"`
}

func (q *Queries) CreateDAGState(ctx context.Context, arg CreateDAGStateParams) (DagState, error) {
	row := q.db.QueryRow(ctx, createDAGState, arg.ID, arg.DagID, arg.DagStatus)
	var i DagState
	err := row.Scan(
		&i.ID,
		&i.DagID,
		&i.DagStatus,
		&i.StartTime,
		&i.EndTime,
		&i.FailureReason,
		&i.CreatedAt,
	)
	return i, err
}

const getCurrentDAGState = `-- name: GetCurrentDAGState :one
SELECT id, dag_id, dag_status, start_time, end_time, failure_reason, created_at
FROM dag_states
WHERE dag_id=$1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetCurrentDAGState(ctx context.Context, dagID uuid.UUID) (DagState, error) {
	row := q.db.QueryRow(ctx, getCurrentDAGState, dagID)
	var i DagState
	err := row.Scan(
		&i.ID,
		&i.DagID,
		&i.DagStatus,
		&i.StartTime,
		&i.EndTime,
		&i.FailureReason,
		&i.CreatedAt,
	)
	return i, err
}

const listDAGStates = `-- name: ListDAGStates :many
SELECT id, dag_id, dag_status, start_time, end_time, failure_reason, created_at 
FROM dag_states 
WHERE dag_id = $1
`

func (q *Queries) ListDAGStates(ctx context.Context, dagID uuid.UUID) ([]DagState, error) {
	rows, err := q.db.Query(ctx, listDAGStates, dagID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DagState
	for rows.Next() {
		var i DagState
		if err := rows.Scan(
			&i.ID,
			&i.DagID,
			&i.DagStatus,
			&i.StartTime,
			&i.EndTime,
			&i.FailureReason,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateDAGStateEndTime = `-- name: UpdateDAGStateEndTime :exec
UPDATE dag_states
SET end_time=$2
WHERE id=$1
`

type UpdateDAGStateEndTimeParams struct {
	ID      uuid.UUID        `json:"id"`
	EndTime pgtype.Timestamp `json:"end_time"`
}

func (q *Queries) UpdateDAGStateEndTime(ctx context.Context, arg UpdateDAGStateEndTimeParams) error {
	_, err := q.db.Exec(ctx, updateDAGStateEndTime, arg.ID, arg.EndTime)
	return err
}

const updateDAGStateFailureReason = `-- name: UpdateDAGStateFailureReason :exec
UPDATE dag_states
SET failure_reason=$2
WHERE id=$1
`

type UpdateDAGStateFailureReasonParams struct {
	ID            uuid.UUID   `json:"id"`
	FailureReason pgtype.Text `json:"failure_reason"`
}

func (q *Queries) UpdateDAGStateFailureReason(ctx context.Context, arg UpdateDAGStateFailureReasonParams) error {
	_, err := q.db.Exec(ctx, updateDAGStateFailureReason, arg.ID, arg.FailureReason)
	return err
}

const updateDAGStateStartTime = `-- name: UpdateDAGStateStartTime :exec
UPDATE dag_states
SET start_time=$2
WHERE id=$1
`

type UpdateDAGStateStartTimeParams struct {
	ID        uuid.UUID        `json:"id"`
	StartTime pgtype.Timestamp `json:"start_time"`
}

func (q *Queries) UpdateDAGStateStartTime(ctx context.Context, arg UpdateDAGStateStartTimeParams) error {
	_, err := q.db.Exec(ctx, updateDAGStateStartTime, arg.ID, arg.StartTime)
	return err
}
